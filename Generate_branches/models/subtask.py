"""
This module defines the SubTask classes that represent different stages within a Task.
There are two types: ScriptedSubTask (manually created) and GeneratedSubTask (LLM generated).
"""

from abc import ABC, abstractmethod

class SubTask(ABC):
    """
    Base abstract class for all subtasks.
    """
    def __init__(self, subtask_id, title, description, layer=0, parent_id=None):
        self.subtask_id = subtask_id
        self.title = title
        self.description = description
        self.layer = layer  # Layer to organize subtasks within a Task
        self.parent_id = parent_id  # ID of the parent subtask (if any)
        self.completed = False
        self.is_generated = None  # Will be set by specific subclass
        
    @abstractmethod
    def execute(self, game_state, player_input=None):
        """
        Execute this subtask based on game state and optional player input.
        Should be implemented by subclasses.
        """
        pass
        
    def mark_completed(self):
        """Mark this subtask as completed."""
        self.completed = True
        
    def is_completed(self, game_state):
        """Check if this subtask is completed."""
        return self.completed
        
    def to_dict(self):
        """Convert subtask to dictionary for storage/serialization."""
        return {
            "subtask_id": self.subtask_id,
            "title": self.title,
            "description": self.description,
            "layer": self.layer,
            "parent_id": self.parent_id,
            "completed": self.completed,
            "is_generated": self.is_generated,
            "type": self.__class__.__name__
        }
    
    @classmethod
    def from_dict(cls, data):
        """Create a SubTask instance from dictionary data."""
        if data["type"] == "ScriptedSubTask":
            return ScriptedSubTask.from_dict(data)
        elif data["type"] == "GeneratedSubTask":
            return GeneratedSubTask.from_dict(data)
        else:
            raise ValueError(f"Unknown subtask type: {data['type']}")


class ScriptedSubTask(SubTask):
    """
    A manually designed subtask with predefined content and transitions.
    """
    def __init__(self, subtask_id, title, description, dialogue, npc_reactions=None, 
                 player_options=None, layer=0, next_transitioning_question=None, parent_id=None):
        super().__init__(subtask_id, title, description, layer, parent_id)
        self.dialogue = dialogue  # Main narrative text for this subtask
        self.npc_reactions = npc_reactions or {}  # Dict of NPC ID to reaction text
        self.player_options = player_options or []  # List of possible player responses
        self.next_transitioning_question = next_transitioning_question  # Question to next subtask
        self.is_generated = False  # Scripted subtasks are not generated by LLM
        
    def execute(self, game_state, player_input=None):
        """
        Execute this scripted subtask.
        
        This method processes the subtask, updates the game state as needed,
        and returns information about the subtask execution.
        
        Args:
            game_state: The current state of the game
            player_input: Optional input from the player
            
        Returns:
            Dictionary with execution results
        """
        # Create the base result dictionary
        result = {
            "dialogue": self.dialogue,
            "npc_reactions": self.npc_reactions,
            "player_options": self.player_options,
            "transitioning_question": self.next_transitioning_question
        }
        
        # Process player input if provided
        if player_input:
            # Record this interaction in game state
            if hasattr(game_state, 'interactions'):
                game_state.interactions.append({
                    "subtask_id": self.subtask_id,
                    "player_input": player_input,
                    "timestamp": game_state.game_timestamp
                })
                
            # Update NPC states based on this interaction
            if player_input in self.player_options:
                # Update NPC reactions based on player choice
                for npc_id, reaction in self.npc_reactions.items():
                    npc_state = game_state.npcs.get(npc_id)
                    if npc_state:
                        # Record memory of this interaction
                        npc_state.add_memory(f"Player chose: {player_input}")
        
        # Mark this subtask as completed
        self.completed = True
        
        return result
        
    def to_dict(self):
        """Convert to dictionary, adding scripted-specific fields."""
        base_dict = super().to_dict()
        base_dict.update({
            "dialogue": self.dialogue,
            "npc_reactions": self.npc_reactions,
            "player_options": self.player_options,
            "next_transitioning_question": self.next_transitioning_question
        })
        return base_dict
        
    @classmethod
    def from_dict(cls, data):
        """Create a ScriptedSubTask from dict data."""
        subtask = cls(
            subtask_id=data["subtask_id"],
            title=data["title"],
            description=data["description"],
            dialogue=data["dialogue"],
            npc_reactions=data.get("npc_reactions", {}),
            player_options=data.get("player_options", []),
            layer=data.get("layer", 0),
            next_transitioning_question=data.get("next_transitioning_question"),
            parent_id=data.get("parent_id")
        )
        subtask.completed = data.get("completed", False)
        subtask.is_generated = False  # Always set to False for ScriptedSubTask
        return subtask


class GeneratedSubTask(SubTask):
    """
    An LLM-generated subtask created based on a transitioning question.
    """
    def __init__(self, subtask_id, title, description, dialogue, npc_reactions=None,
                 player_options=None, layer=0, generation_score=0, 
                 transitioning_question=None, parent_id=None):
        super().__init__(subtask_id, title, description, layer, parent_id)
        self.dialogue = dialogue
        self.npc_reactions = npc_reactions or {}
        self.player_options = player_options or []
        self.generation_score = generation_score  # How highly this was rated by LLM
        self.transitioning_question = transitioning_question  # Question that led to this generation
        self.is_generated = True  # Generated subtasks are created by LLM
        
    def execute(self, game_state, player_input=None):
        """
        Execute this generated subtask.
        
        This method processes the generated subtask, updates the game state,
        and returns information about the execution.
        
        Args:
            game_state: The current state of the game
            player_input: Optional input from the player
            
        Returns:
            Dictionary with execution results
        """
        # Create the base result dictionary
        result = {
            "dialogue": self.dialogue,
            "npc_reactions": self.npc_reactions,
            "player_options": self.player_options,
            "transitioning_question": self.transitioning_question,
            "is_generated": True,
            "generation_score": self.generation_score,
            "needs_generation": True  # Generated subtasks might lead to another generation
        }
        
        # Process player input if provided
        if player_input:
            # Record this interaction in game state
            if hasattr(game_state, 'interactions'):
                game_state.interactions.append({
                    "subtask_id": self.subtask_id,
                    "player_input": player_input,
                    "is_generated": True,
                    "timestamp": game_state.game_timestamp
                })
                
            # Update NPC states based on this interaction
            for npc_id, reaction in self.npc_reactions.items():
                npc_state = game_state.npcs.get(npc_id)
                if npc_state:
                    # Record memory of this interaction with generated content
                    npc_state.add_memory(f"Player interacted with generated content: {player_input}")
        
        # Mark this subtask as completed
        self.completed = True
            
        return result
        
    def to_dict(self):
        """Convert to dictionary, adding generated-specific fields."""
        base_dict = super().to_dict()
        base_dict.update({
            "dialogue": self.dialogue,
            "npc_reactions": self.npc_reactions,
            "player_options": self.player_options,
            "generation_score": self.generation_score,
            "transitioning_question": self.transitioning_question
        })
        return base_dict
        
    @classmethod
    def from_dict(cls, data):
        """Create a GeneratedSubTask from dict data."""
        subtask = cls(
            subtask_id=data["subtask_id"],
            title=data["title"],
            description=data["description"],
            dialogue=data["dialogue"],
            npc_reactions=data.get("npc_reactions", {}),
            player_options=data.get("player_options", []),
            layer=data.get("layer", 0),
            generation_score=data.get("generation_score", 0),
            transitioning_question=data.get("transitioning_question"),
            parent_id=data.get("parent_id")
        )
        subtask.completed = data.get("completed", False)
        subtask.is_generated = True  # Always set to True for GeneratedSubTask
        return subtask 