"""
This module provides utilities for extracting narrative content from JSON files
generated by the FSM-LLM-Narrative system and saving it in a readable text format.
"""

import os
import json
import glob
import argparse
from typing import Dict, List, Optional, Tuple


def extract_narratives_from_task_folder(task_folder: str, output_file: Optional[str] = None) -> str:
    """
    Extract narrative content from JSON files in a specific task folder and save to a text file.
    
    Args:
        task_folder: Path to the task folder (containing key_questions, Scripted_subtask, and Subtask_branches subfolders)
        output_file: Optional path for output text file. If None, will use task folder name for the output file.
        
    Returns:
        Path to the created text file
    """
    # Validate the folder exists
    if not os.path.isdir(task_folder):
        raise ValueError(f"Task folder does not exist: {task_folder}")
    
    # Extract the task name and timestamp from the folder name
    folder_name = os.path.basename(task_folder)
    
    # Set default output file if not provided
    if not output_file:
        output_file = os.path.join(task_folder, f"{folder_name}_narrative.txt")
    
    # Initialize content to write to the file
    content = [f"Narrative Summary for: {folder_name}\n"]
    content.append("=" * 80 + "\n\n")
    
    # Step 1: Extract key questions
    content.append("KEY QUESTIONS\n")
    content.append("-" * 80 + "\n")
    key_questions_path = glob.glob(os.path.join(task_folder, "key_questions_*.json"))
    if key_questions_path:
        try:
            with open(key_questions_path[0], 'r') as f:
                key_questions_data = json.load(f)
                raw_response = key_questions_data.get("raw_response", "")
                # Try to parse the raw_response if it's in JSON format
                try:
                    questions = json.loads(raw_response)
                    for i, question in enumerate(questions, 1):
                        content.append(f"Question {i}: {question}\n")
                except json.JSONDecodeError:
                    # If not valid JSON, use the raw response as is
                    content.append(f"Key Questions: {raw_response}\n")
        except Exception as e:
            content.append(f"Error extracting key questions: {e}\n")
    else:
        content.append("No key questions file found\n")
    
    content.append("\n")
    
    # Step 2: Extract scripted subtasks for each layer
    content.append("SCRIPTED SUBTASKS\n")
    content.append("-" * 80 + "\n")
    
    # Determine the subtask folder pattern
    subtask_folders = glob.glob(os.path.join(task_folder, "Scripted_subtask_*"))
    
    if subtask_folders:
        subtask_folder = subtask_folders[0]  # Use the first found folder
        
        # Look for each layer's subtask
        for layer in range(1, 4):  # Layers 1, 2, 3
            content.append(f"\nLayer {layer} Scripted Subtask:\n")
            
            # Find the layer's subtask file
            layer_files = glob.glob(os.path.join(subtask_folder, f"scripted_subtask_layer{layer}_*.json"))
            
            if layer_files:
                try:
                    with open(layer_files[0], 'r') as f:
                        subtask_data = json.load(f)
                        raw_response = subtask_data.get("raw_response", "")
                        
                        # Try to parse the raw_response if it's in JSON format
                        try:
                            subtask = json.loads(raw_response)
                            content.append(f"Title: {subtask.get('title', 'Unknown')}\n")
                            content.append(f"Description: {subtask.get('description', 'No description')}\n")
                            content.append(f"Dialogue: {subtask.get('dialogue', 'No dialogue')}\n")
                            
                            # Include player options
                            player_options = subtask.get('player_options', [])
                            if player_options:
                                content.append("Player Options:\n")
                                for i, option in enumerate(player_options, 1):
                                    content.append(f"  {i}. {option}\n")
                                
                            # Include NPC reactions
                            npc_reactions = subtask.get('npc_reactions', {})
                            if npc_reactions:
                                content.append("NPC Reactions:\n")
                                for npc, reaction in npc_reactions.items():
                                    content.append(f"  {npc}: {reaction}\n")
                        except json.JSONDecodeError:
                            # If not valid JSON, use the raw response as is
                            content.append(f"Raw response: {raw_response}\n")
                except Exception as e:
                    content.append(f"Error extracting layer {layer} scripted subtask: {e}\n")
            else:
                content.append(f"No scripted subtask file found for layer {layer}\n")
    else:
        content.append("No scripted subtask folder found\n")
    
    content.append("\n")
    
    # Step 3: Extract subtask branches for each layer
    content.append("SUBTASK BRANCHES (ALTERNATIVES)\n")
    content.append("-" * 80 + "\n")
    
    # Determine the branches folder pattern
    branches_folders = glob.glob(os.path.join(task_folder, "Subtask_branches_*"))
    
    if branches_folders:
        branches_folder = branches_folders[0]  # Use the first found folder
        
        # Look for each layer's branches
        for layer in range(1, 4):  # Layers 1, 2, 3
            content.append(f"\nLayer {layer} Alternatives:\n")
            
            # Find the layer's branches file
            layer_files = glob.glob(os.path.join(branches_folder, f"subtask_branches_layer{layer}_*.json"))
            
            if layer_files:
                try:
                    with open(layer_files[0], 'r') as f:
                        branches_data = json.load(f)
                        raw_response = branches_data.get("raw_response", "")
                        
                        # Try to parse the raw_response if it's in JSON format
                        try:
                            branches = json.loads(raw_response)
                            if isinstance(branches, list):
                                for i, branch in enumerate(branches, 1):
                                    content.append(f"\nAlternative {i}:\n")
                                    content.append(f"Title: {branch.get('title', 'Unknown')}\n")
                                    content.append(f"Description: {branch.get('description', 'No description')}\n")
                                    content.append(f"Dialogue: {branch.get('dialogue', 'No dialogue')}\n")
                                    content.append(f"Rating: {branch.get('rating', 'No rating')}\n")
                                    
                                    # Include player options
                                    player_options = branch.get('player_options', [])
                                    if player_options:
                                        content.append("Player Options:\n")
                                        for j, option in enumerate(player_options, 1):
                                            content.append(f"  {j}. {option}\n")
                                        
                                    # Include NPC reactions
                                    npc_reactions = branch.get('npc_reactions', {})
                                    if npc_reactions:
                                        content.append("NPC Reactions:\n")
                                        for npc, reaction in npc_reactions.items():
                                            content.append(f"  {npc}: {reaction}\n")
                            else:
                                content.append(f"Raw response (not a list): {raw_response}\n")
                        except json.JSONDecodeError:
                            # If not valid JSON, use the raw response as is
                            content.append(f"Raw response: {raw_response}\n")
                except Exception as e:
                    content.append(f"Error extracting layer {layer} branches: {e}\n")
            else:
                content.append(f"No subtask branches file found for layer {layer}\n")
    else:
        content.append("No subtask branches folder found\n")
    
    # Write the content to the output file
    with open(output_file, 'w') as f:
        f.writelines(content)
    
    print(f"Narrative summary saved to: {output_file}")
    return output_file


def find_task_folders(base_dir: str = "Generate_branches/data") -> List[str]:
    """
    Find all task folders in the base directory.
    
    Args:
        base_dir: Base directory to search in, defaults to "Generate_branches/data"
        
    Returns:
        List of paths to task folders
    """
    # Create base directory if it doesn't exist
    if not os.path.exists(base_dir):
        return []
    
    # Find all directories that might be task folders
    potential_task_folders = []
    for item in os.listdir(base_dir):
        item_path = os.path.join(base_dir, item)
        if os.path.isdir(item_path):
            # Check if it has key_questions file or subdirectories
            if (glob.glob(os.path.join(item_path, "key_questions_*.json")) or
                glob.glob(os.path.join(item_path, "Scripted_subtask_*")) or
                glob.glob(os.path.join(item_path, "Subtask_branches_*"))):
                potential_task_folders.append(item_path)
    
    return potential_task_folders


def list_tasks(base_dir: str = "Generate_branches/data") -> None:
    """
    List all available task folders.
    
    Args:
        base_dir: Base directory to search in, defaults to "Generate_branches/data"
    """
    task_folders = find_task_folders(base_dir)
    
    if not task_folders:
        print(f"No task folders found in {base_dir}")
        return
    
    print(f"Found {len(task_folders)} task folder(s):")
    for i, folder in enumerate(task_folders, 1):
        folder_name = os.path.basename(folder)
        print(f"{i}. {folder_name}")


def main():
    """Main entry point for the command-line utility."""
    parser = argparse.ArgumentParser(description='Extract narrative content from task folders')
    parser.add_argument('--task', '-t', help='Task folder name or path (if omitted, will list available tasks)')
    parser.add_argument('--output', '-o', help='Output file path (optional)')
    parser.add_argument('--data-dir', '-d', default="Generate_branches/data", 
                        help='Base data directory (default: Generate_branches/data)')
    
    args = parser.parse_args()
    
    # If no task specified, list available tasks
    if not args.task:
        list_tasks(args.data_dir)
        return
    
    # Determine the task folder path
    if os.path.isdir(args.task):
        # Direct path was provided
        task_folder = args.task
    else:
        # Task name was provided, search in data directory
        task_folders = find_task_folders(args.data_dir)
        matching_folders = [f for f in task_folders if args.task in os.path.basename(f)]
        
        if not matching_folders:
            print(f"No task folders matching '{args.task}' found in {args.data_dir}")
            list_tasks(args.data_dir)
            return
        
        if len(matching_folders) > 1:
            print(f"Multiple task folders match '{args.task}':")
            for i, folder in enumerate(matching_folders, 1):
                print(f"{i}. {os.path.basename(folder)}")
            try:
                choice = int(input("Enter the number of the folder to use: "))
                if 1 <= choice <= len(matching_folders):
                    task_folder = matching_folders[choice-1]
                else:
                    print("Invalid choice")
                    return
            except ValueError:
                print("Invalid input")
                return
        else:
            task_folder = matching_folders[0]
    
    # Extract and save the narrative
    try:
        output_file = extract_narratives_from_task_folder(task_folder, args.output)
        print(f"Successfully extracted narrative from {os.path.basename(task_folder)}")
        print(f"Saved to: {output_file}")
    except Exception as e:
        print(f"Error extracting narrative: {e}")


if __name__ == "__main__":
    main() 